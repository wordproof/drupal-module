<?php

use Drupal\Core\Entity\ContentEntityInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\EntityPublishedInterface;
use Drupal\field\Entity\FieldStorageConfig;
use Drupal\wordproof_timestamp\Timestamp\TimestampInterface;

/**
 * @see hook_entity_create()
 */
function wordproof_timestamp_entity_insert(EntityInterface $entity) {
  if (!$entity instanceof ContentEntityInterface || $entity instanceof TimestampInterface) {
    return FALSE;
  }
  if ($entity instanceof EntityPublishedInterface && $entity->isPublished() === FALSE) {
    return FALSE;
  }

  \Drupal::messenger()->addMessage(t('WordProof timestamp for ":title" is queued and the timestamp will appear after approval on the blockchain.', [':title' => $entity->label()]), 'status');

  \Drupal::logger('wordproof_timestamp')->debug('function' . __FUNCTION__);
  \Drupal::logger('wordproof_timestamp')->debug('type' . $entity->getEntityTypeId());
  \Drupal::logger('wordproof_timestamp')->debug('bundle' . $entity->bundle());
  \Drupal::logger('wordproof_timestamp')->debug('label' . $entity->label());

  $timestampBuilder = \Drupal::service('wordproof_timestamp.timestamp_builder_service');
  $timestampBuilder->stamp($entity);
  $timestampBuilder->stampWatchedEntities($entity);

}

/* Start with new node support only */
function wordproof_timestamp_entity_update(EntityInterface $entity) {
  if (!$entity instanceof ContentEntityInterface || $entity instanceof TimestampInterface) {
    return;
  }

  if ($entity instanceof EntityPublishedInterface && $entity->isPublished() === FALSE) {
    return;
  }
  \Drupal::messenger()->addMessage(t('WordProof timestamp for ":title" is queued and the timestamp will appear after approval on the blockchain.', [':title' => $entity->label()]), 'status');

  $timestampBuilder = \Drupal::service('wordproof_timestamp.timestamp_builder_service');
  $timestampBuilder->stamp($entity);
  $timestampBuilder->stampWatchedEntities($entity);
}

/**
 * @see hook_theme().
 */
function wordproof_timestamp_theme($existing, $type, $theme, $path) {
  return [
    'wordproof_certificate' => [
      'variables' => ['timestamp' => NULL],
    ],
  ];
}

/**
 * @see hook_token_info_alter().
 */
function wordproof_timestamp_token_info_alter(&$info) {
  foreach (\Drupal::entityTypeManager()->getDefinitions() as $entity_type_id => $entity_type) {
    if (!$entity_type->entityClassImplements(ContentEntityInterface::class) || $entity_type_id === 'timestamp') {
      continue;
    }

    // Make sure a token type exists for this entity.
    $token_type = \Drupal::service('token.entity_mapper')->getTokenTypeForEntityType($entity_type_id);
    if (empty($token_type) || !isset($info['types'][$token_type])) {
      continue;
    }

    $info['types'][$token_type]['wordproof-timestamp'] = [
      'name' => t('WordProof timestamp'),
      'description' => t('Token for the JSON-LD timestamp of an entity.'),
      'needs-data' => [
        $entity_type_id,
        'timestamp',
      ],
    ];
    $info['tokens'][$token_type]['wordproof-timestamp'] = [
      'name' => t("Wordproof JSON-LD timestamp"),
      'description' => t('The node\'s JSON-LD timestamp'),
      'module' => 'token',
    ];

  }
}

/**
 * Implements hook_tokens().
 */
function wordproof_timestamp_tokens($type, $tokens, array $data, array $options, \Drupal\Core\Render\BubbleableMetadata $bubbleable_metadata) {
  $replacements = [];

  if ($type == 'entity' && !empty($data['entity'])) {
    foreach ($tokens as $name => $original) {
      switch ($name) {
        case 'wordproof-timestamp':
          /** @var TimestampInterface $timestamp */
          $timestamp = \Drupal::service('wordproof_timestamp.repository')->get($data['entity']);
          if ($timestamp) {
            $bubbleable_metadata->addCacheableDependency($timestamp);
            $toJsonLdArray = $timestamp->toJsonLdArray();
            if (count($toJsonLdArray) > 0) {
              $replacements[$original] = json_encode($toJsonLdArray, JSON_UNESCAPED_SLASHES | JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT | JSON_UNESCAPED_UNICODE);
            }
          }
          break;
      }
    }
  }
  return $replacements;
}


